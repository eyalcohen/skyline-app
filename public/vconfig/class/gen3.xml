<config generation="234">
    <!-- All directives for a particular vehicle must be inside a vehicle node, other nodes are ignored -->
    <vehicle id="234142">
        
        <!-- if present turns on the canstream server inside the vehicle (defaults to off) -->
        <canstream enabled="true" />
        
	<!-- If url is set, we will launch a web browser session showing that URL (normally used to show a dash) -->
	<!-- If screenOn is true we will keep the screen from going to sleep when the vehicle is awake (for the dash) -->
	<gui screenOn="true" url="http://localhost:4403/index.html" />

        <subsystem id="mc">
	</subsystem>
        <subsystem id="vc">
	</subsystem>
        <subsystem id="pm">
	</subsystem>

        <!-- specifies (in seconds) the minimum latency for fetching or 
	     uploading files to/from the server.
             minIntervalOn is used when the vehicle is running, 
	     minIntervalOff is used when asleep.

             uploadRoot is where we should squirt our collected data
        -->
        <serverinfo type="upload" minIntervalOn="10"  minIntervalOff="100" url="http://triptrack.ridemission.com/samples" />
        <serverinfo type="download" minIntervalOn="10"  minIntervalOff="100" url="http://triptrack.ridemission.com/vconfig" />

        <canfilter iface="can0">
            <canid channel="2" operation="getShort" param="pm/fault.faultEncoded"/>
            <canid param="pm.*/.*"/>
            <canid param="mc.*/.*"/>
            <canid param="bms.*/fault.*"/>
            <canid channel="2" operation="getShort" param="21/43" isRequest="true"/>
            <canid mask="0x1fffffff" compare="0x123323" extended="true"/>
            <canid mask="0x1ff" compare="0x123" extended="false"/>
        </canfilter>
        <tree>
            <pipe>
                <sourceref>can0Source</sourceref>
                <sourceref>gpsSource</sourceref> 
                <teesink>
                    <!-- <printsink/> -->
		    <!-- interval is bucket length in msecs, maxCount is max # allower per bucket --> 
                    <throttledsink interval="60000" maxCount="1000">
                        <throttledsink interval="1000" maxCount="100">
                            <sinkref>eventSpooler</sinkref>
                        </throttledsink>
                    </throttledsink>
                    <!-- Declare a MC fault if the MC broadcasts a fieldCurrent between 100 and 200 -->
                    <andfiltersink>
                        <filters>
                            <canid param="mc/fieldCurrent" operation="getShort" isRequest="false"/>
                            <gt>100</gt>
                            <lt>200</lt>
                        </filters>
                        <onPass>
                            <!-- If anything makes it to this sink we will trigger-->
                            <triggersink name="mcFault" message="MC fault occurred"/>
                        </onPass>
                    </andfiltersink>
                    <!-- Log recent (and some future) unfiltered PM/MC traffic if a mcFault occurs -->
                    <orfiltersink>
                        <filters>
                            <canid param="mc/.*"/>
                            <canid param="pm/.*"/>
                        </filters>
                        <onPass>
                            <analyzersink triggerSink="mcFault" maxCount="5000" delay="100"/>
                        </onPass>
                    </orfiltersink>
                </teesink>
            </pipe>
        </tree>
    </vehicle>
</config>
