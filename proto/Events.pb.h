// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Events.proto

#ifndef PROTOBUF_Events_2eproto__INCLUDED
#define PROTOBUF_Events_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace event {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Events_2eproto();
void protobuf_AssignDesc_Events_2eproto();
void protobuf_ShutdownFile_Events_2eproto();

class EventHeader;
class LocationData;
class AccelerometerData;
class AnnotationData;
class Event;
class EventStream;

enum EventHeader_EventType {
  EventHeader_EventType_SENSOR_VALID = 0,
  EventHeader_EventType_DRIVE_SESSION = 1,
  EventHeader_EventType_ACCELEROMETER = 2,
  EventHeader_EventType_LOCATION = 3,
  EventHeader_EventType_ANNOTATION = 4
};
bool EventHeader_EventType_IsValid(int value);
const EventHeader_EventType EventHeader_EventType_EventType_MIN = EventHeader_EventType_SENSOR_VALID;
const EventHeader_EventType EventHeader_EventType_EventType_MAX = EventHeader_EventType_ANNOTATION;
const int EventHeader_EventType_EventType_ARRAYSIZE = EventHeader_EventType_EventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EventHeader_EventType_descriptor();
inline const ::std::string& EventHeader_EventType_Name(EventHeader_EventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EventHeader_EventType_descriptor(), value);
}
inline bool EventHeader_EventType_Parse(
    const ::std::string& name, EventHeader_EventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EventHeader_EventType>(
    EventHeader_EventType_descriptor(), name, value);
}
enum EventHeader_SourceType {
  EventHeader_SourceType_SENSOR_ACCEL = 0,
  EventHeader_SourceType_SENSOR_GPS = 1,
  EventHeader_SourceType_SENSOR_CELLPOS = 2,
  EventHeader_SourceType_UNKNOWN = 3
};
bool EventHeader_SourceType_IsValid(int value);
const EventHeader_SourceType EventHeader_SourceType_SourceType_MIN = EventHeader_SourceType_SENSOR_ACCEL;
const EventHeader_SourceType EventHeader_SourceType_SourceType_MAX = EventHeader_SourceType_UNKNOWN;
const int EventHeader_SourceType_SourceType_ARRAYSIZE = EventHeader_SourceType_SourceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EventHeader_SourceType_descriptor();
inline const ::std::string& EventHeader_SourceType_Name(EventHeader_SourceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EventHeader_SourceType_descriptor(), value);
}
inline bool EventHeader_SourceType_Parse(
    const ::std::string& name, EventHeader_SourceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EventHeader_SourceType>(
    EventHeader_SourceType_descriptor(), name, value);
}
// ===================================================================

class EventHeader : public ::google::protobuf::Message {
 public:
  EventHeader();
  virtual ~EventHeader();
  
  EventHeader(const EventHeader& from);
  
  inline EventHeader& operator=(const EventHeader& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EventHeader& default_instance();
  
  void Swap(EventHeader* other);
  
  // implements Message ----------------------------------------------
  
  EventHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventHeader& from);
  void MergeFrom(const EventHeader& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef EventHeader_EventType EventType;
  static const EventType SENSOR_VALID = EventHeader_EventType_SENSOR_VALID;
  static const EventType DRIVE_SESSION = EventHeader_EventType_DRIVE_SESSION;
  static const EventType ACCELEROMETER = EventHeader_EventType_ACCELEROMETER;
  static const EventType LOCATION = EventHeader_EventType_LOCATION;
  static const EventType ANNOTATION = EventHeader_EventType_ANNOTATION;
  static inline bool EventType_IsValid(int value) {
    return EventHeader_EventType_IsValid(value);
  }
  static const EventType EventType_MIN =
    EventHeader_EventType_EventType_MIN;
  static const EventType EventType_MAX =
    EventHeader_EventType_EventType_MAX;
  static const int EventType_ARRAYSIZE =
    EventHeader_EventType_EventType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EventType_descriptor() {
    return EventHeader_EventType_descriptor();
  }
  static inline const ::std::string& EventType_Name(EventType value) {
    return EventHeader_EventType_Name(value);
  }
  static inline bool EventType_Parse(const ::std::string& name,
      EventType* value) {
    return EventHeader_EventType_Parse(name, value);
  }
  
  typedef EventHeader_SourceType SourceType;
  static const SourceType SENSOR_ACCEL = EventHeader_SourceType_SENSOR_ACCEL;
  static const SourceType SENSOR_GPS = EventHeader_SourceType_SENSOR_GPS;
  static const SourceType SENSOR_CELLPOS = EventHeader_SourceType_SENSOR_CELLPOS;
  static const SourceType UNKNOWN = EventHeader_SourceType_UNKNOWN;
  static inline bool SourceType_IsValid(int value) {
    return EventHeader_SourceType_IsValid(value);
  }
  static const SourceType SourceType_MIN =
    EventHeader_SourceType_SourceType_MIN;
  static const SourceType SourceType_MAX =
    EventHeader_SourceType_SourceType_MAX;
  static const int SourceType_ARRAYSIZE =
    EventHeader_SourceType_SourceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SourceType_descriptor() {
    return EventHeader_SourceType_descriptor();
  }
  static inline const ::std::string& SourceType_Name(SourceType value) {
    return EventHeader_SourceType_Name(value);
  }
  static inline bool SourceType_Parse(const ::std::string& name,
      SourceType* value) {
    return EventHeader_SourceType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required uint64 start_time = 1;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 start_time() const;
  inline void set_start_time(::google::protobuf::uint64 value);
  
  // optional uint64 stop_time = 2;
  inline bool has_stop_time() const;
  inline void clear_stop_time();
  static const int kStopTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 stop_time() const;
  inline void set_stop_time(::google::protobuf::uint64 value);
  
  // required .event.EventHeader.EventType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::event::EventHeader_EventType type() const;
  inline void set_type(::event::EventHeader_EventType value);
  
  // optional .event.EventHeader.SourceType source = 4;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 4;
  inline ::event::EventHeader_SourceType source() const;
  inline void set_source(::event::EventHeader_SourceType value);
  
  // @@protoc_insertion_point(class_scope:event.EventHeader)
 private:
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_stop_time();
  inline void clear_has_stop_time();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_source();
  inline void clear_has_source();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 start_time_;
  ::google::protobuf::uint64 stop_time_;
  int type_;
  int source_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Events_2eproto();
  friend void protobuf_AssignDesc_Events_2eproto();
  friend void protobuf_ShutdownFile_Events_2eproto();
  
  void InitAsDefaultInstance();
  static EventHeader* default_instance_;
};
// -------------------------------------------------------------------

class LocationData : public ::google::protobuf::Message {
 public:
  LocationData();
  virtual ~LocationData();
  
  LocationData(const LocationData& from);
  
  inline LocationData& operator=(const LocationData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocationData& default_instance();
  
  void Swap(LocationData* other);
  
  // implements Message ----------------------------------------------
  
  LocationData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocationData& from);
  void MergeFrom(const LocationData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float latitude = 2;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  inline float latitude() const;
  inline void set_latitude(float value);
  
  // optional float longitude = 3;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 3;
  inline float longitude() const;
  inline void set_longitude(float value);
  
  // optional int32 altitude = 4;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 4;
  inline ::google::protobuf::int32 altitude() const;
  inline void set_altitude(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:event.LocationData)
 private:
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_altitude();
  inline void clear_has_altitude();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float latitude_;
  float longitude_;
  ::google::protobuf::int32 altitude_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Events_2eproto();
  friend void protobuf_AssignDesc_Events_2eproto();
  friend void protobuf_ShutdownFile_Events_2eproto();
  
  void InitAsDefaultInstance();
  static LocationData* default_instance_;
};
// -------------------------------------------------------------------

class AccelerometerData : public ::google::protobuf::Message {
 public:
  AccelerometerData();
  virtual ~AccelerometerData();
  
  AccelerometerData(const AccelerometerData& from);
  
  inline AccelerometerData& operator=(const AccelerometerData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccelerometerData& default_instance();
  
  void Swap(AccelerometerData* other);
  
  // implements Message ----------------------------------------------
  
  AccelerometerData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccelerometerData& from);
  void MergeFrom(const AccelerometerData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline float x() const;
  inline void set_x(float value);
  
  // optional float y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline float y() const;
  inline void set_y(float value);
  
  // optional float z = 4;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 4;
  inline float z() const;
  inline void set_z(float value);
  
  // @@protoc_insertion_point(class_scope:event.AccelerometerData)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_;
  float y_;
  float z_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Events_2eproto();
  friend void protobuf_AssignDesc_Events_2eproto();
  friend void protobuf_ShutdownFile_Events_2eproto();
  
  void InitAsDefaultInstance();
  static AccelerometerData* default_instance_;
};
// -------------------------------------------------------------------

class AnnotationData : public ::google::protobuf::Message {
 public:
  AnnotationData();
  virtual ~AnnotationData();
  
  AnnotationData(const AnnotationData& from);
  
  inline AnnotationData& operator=(const AnnotationData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AnnotationData& default_instance();
  
  void Swap(AnnotationData* other);
  
  // implements Message ----------------------------------------------
  
  AnnotationData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnnotationData& from);
  void MergeFrom(const AnnotationData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // @@protoc_insertion_point(class_scope:event.AnnotationData)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* message_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Events_2eproto();
  friend void protobuf_AssignDesc_Events_2eproto();
  friend void protobuf_ShutdownFile_Events_2eproto();
  
  void InitAsDefaultInstance();
  static AnnotationData* default_instance_;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message {
 public:
  Event();
  virtual ~Event();
  
  Event(const Event& from);
  
  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();
  
  void Swap(Event* other);
  
  // implements Message ----------------------------------------------
  
  Event* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .event.EventHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::event::EventHeader& header() const;
  inline ::event::EventHeader* mutable_header();
  inline ::event::EventHeader* release_header();
  
  // optional .event.LocationData location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline const ::event::LocationData& location() const;
  inline ::event::LocationData* mutable_location();
  inline ::event::LocationData* release_location();
  
  // optional .event.AccelerometerData accelerometer = 3;
  inline bool has_accelerometer() const;
  inline void clear_accelerometer();
  static const int kAccelerometerFieldNumber = 3;
  inline const ::event::AccelerometerData& accelerometer() const;
  inline ::event::AccelerometerData* mutable_accelerometer();
  inline ::event::AccelerometerData* release_accelerometer();
  
  // optional .event.AnnotationData annotation = 4;
  inline bool has_annotation() const;
  inline void clear_annotation();
  static const int kAnnotationFieldNumber = 4;
  inline const ::event::AnnotationData& annotation() const;
  inline ::event::AnnotationData* mutable_annotation();
  inline ::event::AnnotationData* release_annotation();
  
  // @@protoc_insertion_point(class_scope:event.Event)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_accelerometer();
  inline void clear_has_accelerometer();
  inline void set_has_annotation();
  inline void clear_has_annotation();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::event::EventHeader* header_;
  ::event::LocationData* location_;
  ::event::AccelerometerData* accelerometer_;
  ::event::AnnotationData* annotation_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Events_2eproto();
  friend void protobuf_AssignDesc_Events_2eproto();
  friend void protobuf_ShutdownFile_Events_2eproto();
  
  void InitAsDefaultInstance();
  static Event* default_instance_;
};
// -------------------------------------------------------------------

class EventStream : public ::google::protobuf::Message {
 public:
  EventStream();
  virtual ~EventStream();
  
  EventStream(const EventStream& from);
  
  inline EventStream& operator=(const EventStream& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EventStream& default_instance();
  
  void Swap(EventStream* other);
  
  // implements Message ----------------------------------------------
  
  EventStream* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventStream& from);
  void MergeFrom(const EventStream& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string vehicle_id = 1;
  inline bool has_vehicle_id() const;
  inline void clear_vehicle_id();
  static const int kVehicleIdFieldNumber = 1;
  inline const ::std::string& vehicle_id() const;
  inline void set_vehicle_id(const ::std::string& value);
  inline void set_vehicle_id(const char* value);
  inline void set_vehicle_id(const char* value, size_t size);
  inline ::std::string* mutable_vehicle_id();
  inline ::std::string* release_vehicle_id();
  
  // repeated .event.Event events = 2;
  inline int events_size() const;
  inline void clear_events();
  static const int kEventsFieldNumber = 2;
  inline const ::event::Event& events(int index) const;
  inline ::event::Event* mutable_events(int index);
  inline ::event::Event* add_events();
  inline const ::google::protobuf::RepeatedPtrField< ::event::Event >&
      events() const;
  inline ::google::protobuf::RepeatedPtrField< ::event::Event >*
      mutable_events();
  
  // @@protoc_insertion_point(class_scope:event.EventStream)
 private:
  inline void set_has_vehicle_id();
  inline void clear_has_vehicle_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* vehicle_id_;
  ::google::protobuf::RepeatedPtrField< ::event::Event > events_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Events_2eproto();
  friend void protobuf_AssignDesc_Events_2eproto();
  friend void protobuf_ShutdownFile_Events_2eproto();
  
  void InitAsDefaultInstance();
  static EventStream* default_instance_;
};
// ===================================================================


// ===================================================================

// EventHeader

// required uint64 start_time = 1;
inline bool EventHeader::has_start_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventHeader::set_has_start_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventHeader::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventHeader::clear_start_time() {
  start_time_ = GOOGLE_ULONGLONG(0);
  clear_has_start_time();
}
inline ::google::protobuf::uint64 EventHeader::start_time() const {
  return start_time_;
}
inline void EventHeader::set_start_time(::google::protobuf::uint64 value) {
  set_has_start_time();
  start_time_ = value;
}

// optional uint64 stop_time = 2;
inline bool EventHeader::has_stop_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EventHeader::set_has_stop_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EventHeader::clear_has_stop_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EventHeader::clear_stop_time() {
  stop_time_ = GOOGLE_ULONGLONG(0);
  clear_has_stop_time();
}
inline ::google::protobuf::uint64 EventHeader::stop_time() const {
  return stop_time_;
}
inline void EventHeader::set_stop_time(::google::protobuf::uint64 value) {
  set_has_stop_time();
  stop_time_ = value;
}

// required .event.EventHeader.EventType type = 3;
inline bool EventHeader::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EventHeader::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EventHeader::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EventHeader::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::event::EventHeader_EventType EventHeader::type() const {
  return static_cast< ::event::EventHeader_EventType >(type_);
}
inline void EventHeader::set_type(::event::EventHeader_EventType value) {
  GOOGLE_DCHECK(::event::EventHeader_EventType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .event.EventHeader.SourceType source = 4;
inline bool EventHeader::has_source() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EventHeader::set_has_source() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EventHeader::clear_has_source() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EventHeader::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::event::EventHeader_SourceType EventHeader::source() const {
  return static_cast< ::event::EventHeader_SourceType >(source_);
}
inline void EventHeader::set_source(::event::EventHeader_SourceType value) {
  GOOGLE_DCHECK(::event::EventHeader_SourceType_IsValid(value));
  set_has_source();
  source_ = value;
}

// -------------------------------------------------------------------

// LocationData

// optional float latitude = 2;
inline bool LocationData::has_latitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationData::set_has_latitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationData::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationData::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline float LocationData::latitude() const {
  return latitude_;
}
inline void LocationData::set_latitude(float value) {
  set_has_latitude();
  latitude_ = value;
}

// optional float longitude = 3;
inline bool LocationData::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationData::set_has_longitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationData::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocationData::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline float LocationData::longitude() const {
  return longitude_;
}
inline void LocationData::set_longitude(float value) {
  set_has_longitude();
  longitude_ = value;
}

// optional int32 altitude = 4;
inline bool LocationData::has_altitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocationData::set_has_altitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocationData::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocationData::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline ::google::protobuf::int32 LocationData::altitude() const {
  return altitude_;
}
inline void LocationData::set_altitude(::google::protobuf::int32 value) {
  set_has_altitude();
  altitude_ = value;
}

// -------------------------------------------------------------------

// AccelerometerData

// optional float x = 2;
inline bool AccelerometerData::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccelerometerData::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccelerometerData::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccelerometerData::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float AccelerometerData::x() const {
  return x_;
}
inline void AccelerometerData::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 3;
inline bool AccelerometerData::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccelerometerData::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccelerometerData::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccelerometerData::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float AccelerometerData::y() const {
  return y_;
}
inline void AccelerometerData::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional float z = 4;
inline bool AccelerometerData::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccelerometerData::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccelerometerData::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccelerometerData::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float AccelerometerData::z() const {
  return z_;
}
inline void AccelerometerData::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// AnnotationData

// optional string message = 1;
inline bool AnnotationData::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnnotationData::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnnotationData::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnnotationData::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& AnnotationData::message() const {
  return *message_;
}
inline void AnnotationData::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void AnnotationData::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void AnnotationData::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AnnotationData::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* AnnotationData::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Event

// required .event.EventHeader header = 1;
inline bool Event::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event::clear_header() {
  if (header_ != NULL) header_->::event::EventHeader::Clear();
  clear_has_header();
}
inline const ::event::EventHeader& Event::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::event::EventHeader* Event::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::event::EventHeader;
  return header_;
}
inline ::event::EventHeader* Event::release_header() {
  clear_has_header();
  ::event::EventHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// optional .event.LocationData location = 2;
inline bool Event::has_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event::set_has_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event::clear_has_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event::clear_location() {
  if (location_ != NULL) location_->::event::LocationData::Clear();
  clear_has_location();
}
inline const ::event::LocationData& Event::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::event::LocationData* Event::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::event::LocationData;
  return location_;
}
inline ::event::LocationData* Event::release_location() {
  clear_has_location();
  ::event::LocationData* temp = location_;
  location_ = NULL;
  return temp;
}

// optional .event.AccelerometerData accelerometer = 3;
inline bool Event::has_accelerometer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event::set_has_accelerometer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event::clear_has_accelerometer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event::clear_accelerometer() {
  if (accelerometer_ != NULL) accelerometer_->::event::AccelerometerData::Clear();
  clear_has_accelerometer();
}
inline const ::event::AccelerometerData& Event::accelerometer() const {
  return accelerometer_ != NULL ? *accelerometer_ : *default_instance_->accelerometer_;
}
inline ::event::AccelerometerData* Event::mutable_accelerometer() {
  set_has_accelerometer();
  if (accelerometer_ == NULL) accelerometer_ = new ::event::AccelerometerData;
  return accelerometer_;
}
inline ::event::AccelerometerData* Event::release_accelerometer() {
  clear_has_accelerometer();
  ::event::AccelerometerData* temp = accelerometer_;
  accelerometer_ = NULL;
  return temp;
}

// optional .event.AnnotationData annotation = 4;
inline bool Event::has_annotation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Event::set_has_annotation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Event::clear_has_annotation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Event::clear_annotation() {
  if (annotation_ != NULL) annotation_->::event::AnnotationData::Clear();
  clear_has_annotation();
}
inline const ::event::AnnotationData& Event::annotation() const {
  return annotation_ != NULL ? *annotation_ : *default_instance_->annotation_;
}
inline ::event::AnnotationData* Event::mutable_annotation() {
  set_has_annotation();
  if (annotation_ == NULL) annotation_ = new ::event::AnnotationData;
  return annotation_;
}
inline ::event::AnnotationData* Event::release_annotation() {
  clear_has_annotation();
  ::event::AnnotationData* temp = annotation_;
  annotation_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// EventStream

// required string vehicle_id = 1;
inline bool EventStream::has_vehicle_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventStream::set_has_vehicle_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventStream::clear_has_vehicle_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventStream::clear_vehicle_id() {
  if (vehicle_id_ != &::google::protobuf::internal::kEmptyString) {
    vehicle_id_->clear();
  }
  clear_has_vehicle_id();
}
inline const ::std::string& EventStream::vehicle_id() const {
  return *vehicle_id_;
}
inline void EventStream::set_vehicle_id(const ::std::string& value) {
  set_has_vehicle_id();
  if (vehicle_id_ == &::google::protobuf::internal::kEmptyString) {
    vehicle_id_ = new ::std::string;
  }
  vehicle_id_->assign(value);
}
inline void EventStream::set_vehicle_id(const char* value) {
  set_has_vehicle_id();
  if (vehicle_id_ == &::google::protobuf::internal::kEmptyString) {
    vehicle_id_ = new ::std::string;
  }
  vehicle_id_->assign(value);
}
inline void EventStream::set_vehicle_id(const char* value, size_t size) {
  set_has_vehicle_id();
  if (vehicle_id_ == &::google::protobuf::internal::kEmptyString) {
    vehicle_id_ = new ::std::string;
  }
  vehicle_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventStream::mutable_vehicle_id() {
  set_has_vehicle_id();
  if (vehicle_id_ == &::google::protobuf::internal::kEmptyString) {
    vehicle_id_ = new ::std::string;
  }
  return vehicle_id_;
}
inline ::std::string* EventStream::release_vehicle_id() {
  clear_has_vehicle_id();
  if (vehicle_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vehicle_id_;
    vehicle_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .event.Event events = 2;
inline int EventStream::events_size() const {
  return events_.size();
}
inline void EventStream::clear_events() {
  events_.Clear();
}
inline const ::event::Event& EventStream::events(int index) const {
  return events_.Get(index);
}
inline ::event::Event* EventStream::mutable_events(int index) {
  return events_.Mutable(index);
}
inline ::event::Event* EventStream::add_events() {
  return events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::event::Event >&
EventStream::events() const {
  return events_;
}
inline ::google::protobuf::RepeatedPtrField< ::event::Event >*
EventStream::mutable_events() {
  return &events_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace event

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::event::EventHeader_EventType>() {
  return ::event::EventHeader_EventType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::event::EventHeader_SourceType>() {
  return ::event::EventHeader_SourceType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Events_2eproto__INCLUDED
